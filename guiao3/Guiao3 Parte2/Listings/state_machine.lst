C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE STATE_MACHINE
OBJECT MODULE PLACED IN .\Objects\state_machine.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE state_machine.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\state_machine.lst) TABS(2) OBJECT(.\Objects\state_machine.obj)

line level    source

   1          #include <REG51F380.H>
   2          #include "init_device.h"
   3          #include <string.h>
   4          
   5          #define B_TF3H 7
   6          #define B_TR3 2
   7          #define B_ET3 7
   8          
   9          sbit pb1 = P0^6;
  10          sbit pb2 = P0^7;
  11          
  12          //chave por defeito               8     0     5     1
  13          unsigned char default_key[4] = {0x80, 0xC0, 0x92, 0xF9};
  14           
  15          //                                  L     0     1     2     3     4     5     6     7     8     9
  16          unsigned char digits_array[11] = {0xC7, 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
  17          unsigned char button1pressed; //flags se os botoes sao clicados
  18          unsigned char button2pressed;
  19          unsigned char wrongkeycount;
  20          
  21          //uart utils
  22          //para o locked state:
  23          unsigned char inputKeyBuffer[4]; // 4 pq 8051 4 digitos
  24          unsigned char bufferKeyIndex = -1; // come�a a -1 pq dando debug vi que na primeira passagem o codigo da
             - flag ao RI0
  25          
  26          //para o alarm state:
  27          unsigned char inputAlarmBuffer[5]; // 5 pq reset 5 digitos 
  28          unsigned char bufferAlarmIndex = 0; // mesma explica��o
  29          
  30          // para o admin
  31          unsigned char inputAdminBuffer[3]; // 3 pq *#(L O P E A) locked opened program error alarm
  32          unsigned char bufferAdminIndex = 0; // mesma explica��o
  33          
  34          //unsigned char teste_vetor[] = {'1','2','3','4'};
  35          
  36           
  37          
  38          /*********************************************************/
  39          typedef enum ENUM_STATES {S1 = 0, S2, S3, S4, S5} e_states;
  40          
  41          e_states state, nextstate;
  42          
  43          /* function prototypes */
  44          void state_1(void);
  45          void state_2(void);
  46          void state_3(void);
  47          void state_4(void);
  48          void state_5(void);
  49          
  50          void timer3_init_auto(int reload){
  51   1      
  52   1        TMR3CN = 0;
  53   1      
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 2   

  54   1        #define B_T3MH 7  
  55   1      
  56   1        CKCON &= ~((1 << B_T3MH));
  57   1        
  58   1        TMR3H = (reload) >> 8;
  59   1        TMR3L = (reload);
  60   1      
  61   1        TMR3RLH = (reload) >> 8;
  62   1        TMR3RLL = (reload);
  63   1        
  64   1      }
  65          
  66          
  67          void timer2_init_auto(int reload){
  68   1      
  69   1        TMR2CN = 0;
  70   1      
  71   1        #define B_T2MH 5  
  72   1      
  73   1        CKCON &= ~((1 << B_T2MH));
  74   1        
  75   1        TMR2H = (reload) >> 8;
  76   1        TMR2L = (reload);
  77   1      
  78   1        TMR2RLH = (reload) >> 8;
  79   1        TMR2RLL = (reload);
  80   1        
  81   1      }
  82          
  83          void delay_250us(){
  84   1        while(!(TMR3CN & (1 << B_TF3H)));
  85   1        TMR3CN &= ~(1 << B_TF3H);  
  86   1      }
  87          
  88          void delay_s(unsigned int s) {
  89   1          unsigned int i = 0;
  90   1      
  91   1          while(i != (s*100)) {
  92   2              i++;
  93   2              while(!TF2H);
  94   2              TF2H = 0;
  95   2          }
  96   1      }
  97          
  98          // validar a key introduzida pelo utilizador
  99          bit validate_key(unsigned char v1[4], unsigned char v2[4]){
 100   1        return memcmp(v1, v2, 4) == 0;
 101   1      }
 102          
 103          //DEBOUNCE
 104          unsigned int debounce(bit PB){
 105   1              char window = 0;  
 106   1              unsigned int j;
 107   1          for(j = 0; j < 8; j++) {
 108   2              window = (window << 1) | PB;
 109   2          }
 110   1          return window;
 111   1      }
 112          
 113          // ler a key a ser posta pelo utilizador
 114          void read_key(){
 115   1          unsigned char button1pressed; //flags se os botoes sao clicados
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 3   

 116   1          unsigned char button2pressed;
 117   1          unsigned int digit_index;     //index dos digitos
 118   1          unsigned int index_input_key; //index da key a ser lida
 119   1          unsigned char input_key[4];
 120   1          
 121   1      
 122   1        if(!debounce(pb2) && !button2pressed){
 123   2            button2pressed = 1; 
 124   2            input_key[index_input_key] = digits_array[digit_index];
 125   2            index_input_key++;
 126   2            digit_index = 0;
 127   2          }
 128   1          if(index_input_key == 4){
 129   2            if(validate_key(input_key,default_key)){
 130   3              index_input_key = 0;
 131   3              wrongkeycount = 0;
 132   3              nextstate = S2;
 133   3            }
 134   2            else{
 135   3              index_input_key = 0;
 136   3              nextstate = S3;
 137   3            }
 138   2          }
 139   1          if(debounce(pb2)){
 140   2            button2pressed = 0;
 141   2          }
 142   1        
 143   1          if(!debounce(pb1) && !button1pressed) {
 144   2            
 145   2            button1pressed = 1;            
 146   2            if (digit_index < 11) {
 147   3              digit_index++;
 148   3            }
 149   2            if (digit_index > 10){
 150   3              digit_index = 0;
 151   3            }
 152   2          }
 153   1          if(debounce(pb1)){
 154   2            button1pressed = 0;
 155   2          }
 156   1      
 157   1          P2 = digits_array[digit_index];
 158   1      }
 159          
 160          void errorhandling(){
 161   1          wrongkeycount++;
 162   1          if(wrongkeycount == 1){
 163   2            P2 = 0x86; // E
 164   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 4
             - segundos num total de 5 segundos
 165   2            P2 = 0xC6; // C
 166   2            delay_s(4);//wait 4 secs
 167   2            nextstate = S4;
 168   2          }
 169   1          if(wrongkeycount == 2){
 170   2            P2 = 0x86; // E
 171   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 9
             - segundos
 172   2            P2 = 0xC6; // C
 173   2            delay_s(9);//wait 9 secs
 174   2            nextstate = S1;
 175   2          }
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 4   

 176   1          if(wrongkeycount == 3){
 177   2            P2 = 0x86; // E
 178   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 1
             -4 segundos
 179   2            P2 = 0xC6; // C
 180   2            delay_s(14);//wait 14 secs
 181   2            nextstate = S1;
 182   2          }
 183   1          if(wrongkeycount == 4){
 184   2            P2 = 0x86; // E
 185   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 1
             -9 segundos
 186   2            P2 = 0xC6; // C
 187   2            delay_s(19);//wait 19 secs
 188   2            nextstate = S1;
 189   2          }
 190   1          if(wrongkeycount == 5){
 191   2            nextstate = S4;
 192   2          }
 193   1      }
 194          
 195          void open_menu(){//                 O       P     C
 196   1          unsigned int open_menu[3] = {0xA3 , 0x8C, 0xC6};
 197   1          unsigned int index;
 198   1          
 199   1          if(!debounce(pb2) && !button2pressed){
 200   2            button2pressed = 1;
 201   2            if(open_menu[index] == 0x8C){
 202   3              nextstate = S5;
 203   3              index = 0;
 204   3            }
 205   2            if(open_menu[index] == 0xC6){
 206   3              nextstate = S1;
 207   3              index = 0;
 208   3            }
 209   2          }
 210   1          
 211   1          if(debounce(pb2)){
 212   2            button2pressed = 0;
 213   2          }
 214   1          
 215   1          if(!debounce(pb1) && !button1pressed){
 216   2            
 217   2            
 218   2            button1pressed = 1;            
 219   2            if (index < 3){
 220   3              index++;
 221   3            }
 222   2            if (index > 2){
 223   3              index = 0;
 224   3            }
 225   2          }
 226   1          
 227   1          if(debounce(pb1)){
 228   2            button1pressed = 0;
 229   2          }
 230   1      
 231   1          P2 = open_menu[index];
 232   1        
 233   1      }
 234          void set_key(){//                 P     0     1     2     3     4     5     6     7     8     9
 235   1          unsigned int set_key[11] = {0x8C, 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 5   

 236   1          unsigned int index;
 237   1          unsigned int index_new_key;
 238   1          
 239   1          if(!debounce(pb2) && !button2pressed){
 240   2            button2pressed = 1;
 241   2            default_key[index_new_key] = set_key[index];
 242   2            index_new_key++;
 243   2            index = 0;
 244   2          }
 245   1          
 246   1          if(index_new_key == 4){
 247   2            index_new_key = 0;
 248   2            nextstate = S1;
 249   2          }
 250   1          
 251   1          if(debounce(pb2)){
 252   2            button2pressed = 0;
 253   2          }
 254   1          
 255   1          if(!debounce(pb1) && !button1pressed){
 256   2            
 257   2            button1pressed = 1;            
 258   2            if (index < 11){
 259   3              index++;
 260   3            }
 261   2            if (index > 10){
 262   3              index = 0;
 263   3            }
 264   2          }
 265   1          
 266   1          if(debounce(pb1)){
 267   2            button1pressed = 0;
 268   2          }
 269   1      
 270   1          P2 = set_key[index];
 271   1      }
 272          
 273          // locked state
 274          void uartCheckBufferKey(){
 275   1        if (RI0 == 1) {
 276   2            RI0 = 0;
 277   2          
 278   2      
 279   2          
 280   2          if (bufferKeyIndex < 4) {
 281   3            // le o que est� no buffer
 282   3            inputKeyBuffer[bufferKeyIndex] = SBUF0;
 283   3            bufferKeyIndex++;
 284   3          }
 285   2        }
 286   1        if (bufferKeyIndex == 4) {
 287   2            // compara o vetor com '8051'
 288   2            if (inputKeyBuffer[0] == '8' && inputKeyBuffer[1] == '0' && inputKeyBuffer[2] == '5' && inputKeyBuffer[
             -3] == '1'){
 289   3              nextstate = S2;
 290   3              bufferKeyIndex = 0;
 291   3      
 292   3            } else {
 293   3              bufferKeyIndex = 0;
 294   3              nextstate = S3;
 295   3            }
 296   2          }
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 6   

 297   1      }
 298          
 299          // alarm state
 300          char uartAlarm() {
 301   1      
 302   1          if (RI0 == 1) {
 303   2            RI0 = 0;
 304   2          
 305   2          if (bufferAlarmIndex == 4) {
 306   3            // Compare the inputBuffer with the key "8051"
 307   3            if (inputAlarmBuffer[0] == 'r' && inputAlarmBuffer[1] == 'e' && inputAlarmBuffer[2] == 's' && inputAlar
             -mBuffer[3] == 'e' && inputAlarmBuffer[4] == 't'){
 308   4              nextstate = S1;
 309   4              bufferAlarmIndex = 0;
 310   4              return 0;
 311   4            }
 312   3            else {
 313   4            bufferAlarmIndex = 0;
 314   4            }
 315   3          }
 316   2      
 317   2          if (bufferAlarmIndex < 4) {
 318   3              // le o que est� no buffer
 319   3              inputAlarmBuffer[bufferAlarmIndex] = SBUF0;
 320   3              bufferAlarmIndex++;
 321   3            }   
 322   2          }
 323   1        return 1; 
 324   1      }
 325          
 326          void square_wave(){
 327   1        char loop = 1;
 328   1        while (loop){ // mudar para aceitar a HWFLAG
 329   2          loop = uartAlarm();
 330   2          //HIGH
 331   2          P1 |= 0x80;
 332   2          delay_250us();
 333   2          //LOW
 334   2          P1 &= ~(0x80);
 335   2          delay_250us();
 336   2        }
 337   1      }
 338          
 339          //admin codes
 340          void uartAdmin() {
 341   1      
 342   1          if (RI0 == 1) {
 343   2              RI0 = 0;
 344   2          if (bufferAdminIndex < 3) {
 345   3            // le o que est� no buffer
 346   3            inputAdminBuffer[bufferAdminIndex] = SBUF0;
 347   3            bufferAdminIndex++;
 348   3          }
 349   2          else {
 350   3            bufferAdminIndex = 0;
 351   3          }
 352   2          
 353   2          if (bufferAdminIndex == 3) {
 354   3            // Compare the inputBuffer with the key "8051"
 355   3            if (inputAdminBuffer[0] == '*' && inputAdminBuffer[1] == '#'){
 356   4              if (inputAdminBuffer[3] == 'L'){
 357   5                nextstate = S1;
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 7   

 358   5              }
 359   4              if (inputAdminBuffer[3] == 'O'){
 360   5                nextstate = S2;
 361   5              }
 362   4              if (inputAdminBuffer[3] == 'P'){
 363   5                nextstate = S5;
 364   5              }
 365   4              if (inputAdminBuffer[3] == 'E'){
 366   5                nextstate = S3;
 367   5              }
 368   4              if (inputAdminBuffer[3] == 'A'){
 369   5                nextstate = S4;
 370   5              }
 371   4            }
 372   3          }   
 373   2          } 
 374   1      }
 375          
 376          void sendUart(char vectorToBuffer[]) {
 377   1          unsigned char i = 0;
 378   1      
 379   1          // Wait for the previous transmission to complete
 380   1          while (TI0 == 0);
 381   1        
 382   1      //    SBUF0 = vectorToBuffer[0];
 383   1      //    SBUF0 = vectorToBuffer[1];
 384   1      //    SBUF0 = vectorToBuffer[2];
 385   1      //    SBUF0 = vectorToBuffer[3];
 386   1      
 387   1          // Send each element of the array
 388   1          for (i = 0; i < sizeof(vectorToBuffer); i++) {
 389   2              SBUF0 = vectorToBuffer[i];
 390   2      
 391   2              // Wait for the current byte to be transmitted
 392   2              while (TI0 == 0);
 393   2              TI0 = 0;
 394   2          }
 395   1      
 396   1          // Clear the transmit interrupt flag
 397   1          
 398   1      }
 399          
 400          /*********************************************************/ 
 401          //                          close/locked    open    error     alarm   set_key
 402          void (*state_process [])(void) = {state_1, state_2, state_3, state_4, state_5};
 403          
 404          
 405          void state_1(void){
 406   1        read_key();
 407   1        P1 = 0x10;
 408   1        //sendUart(teste_vetor);
 409   1        uartCheckBufferKey();
 410   1      }
 411          void state_2(void){ // opened
 412   1        open_menu();
 413   1        P1 &= ~(0x10);
 414   1      }
 415          void state_3(void){ //error
 416   1        errorhandling();
 417   1      }
 418          void state_4(void){ // alarm
 419   1        P2 = 0x88;
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     11/21/2023 21:57:55 PAGE 8   

 420   1        square_wave();
 421   1        
 422   1      }
 423          void state_5(void){ // program/set_key
 424   1        set_key();
 425   1      }
 426          
 427          /*********************************************************/
 428          void encode_FSM(){
 429   1          state_process[state] ();
 430   1      }
 431          
 432          /*********************************************************/
 433          
 434          
 435          /*********************************************************
 436           *    main function                                      *
 437           *********************************************************/
 438          void main (void){
 439   1        
 440   1        Init_Device(); 
 441   1        
 442   1        timer2_init_auto(-40000);
 443   1        timer3_init_auto(-1000);
 444   1        
 445   1        state = nextstate = S1;
 446   1        
 447   1        //Set by hardware when the Timer 2/3 high byte overflows from 0xFF to 0x00. In 16 bit 
 448   1        //mode, this will occur when Timer 2/3 overflows from 0xFFFF to 0x0000.   
 449   1        TF2H = 0; 
 450   1        TMR3CN &= ~(1 << B_TF3H);
 451   1        
 452   1        // Enable Flag Timer 2/3 Overflow
 453   1        ET2 = 1;
 454   1        EIE1 |= (1 << B_ET3);
 455   1        
 456   1        // Timer 2/3 Run Control. Timer 2/3 is enabled by setting this bit to 1. 
 457   1        TMR3CN |= (1 << B_TR3);
 458   1        TR2 = 1;
 459   1            
 460   1        while (1) {
 461   2          //uartAdmin();
 462   2          encode_FSM();
 463   2          state = nextstate;
 464   2        }
 465   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1354    ----
   CONSTANT SIZE    =     28    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =    116    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
