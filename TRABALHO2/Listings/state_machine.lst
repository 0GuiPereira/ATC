<<<<<<< HEAD
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     01/07/2024 21:18:11 PAGE 1   
=======
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     01/07/2024 17:39:18 PAGE 1   
>>>>>>> parent of a1d659e (falta fazer, tudo a funcionar)


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE STATE_MACHINE
OBJECT MODULE PLACED IN .\Objects\state_machine.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE state_machine.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\List
                    -ings\state_machine.lst) TABS(2) OBJECT(.\Objects\state_machine.obj)

line level    source

   1          #include <REG51F380.H>
   2          #include <REG51F380.H>
   3          #include <stdio.h>
   4          #include "config_platform.h"
   5          #include "serialIO.h"
   6          #include "timer2_delay.h"
   7          
   8          sbit pb1 = P0^6;
   9          sbit pb2 = P0^7;
  10          
  11          char code *ptr;
  12          
  13          char code sentidoNorteSul[] = "Hello uart0 m0\r\n";
  14          char code sentidoEsteOeste[] = "testeEO\r\n";
  15          
<<<<<<< HEAD
  16          char code estradaVerde[] = "Semaforo Estrada Verde\r\n";
  17          char code estradaAmarelo[] = "Semaforo Estrada Amarelo\r\n";
  18          char code estradaVermelho[] = "Semaforo Estrada Vermelho\r\n";
  19          
  20          char code passadeiraVerde[] = "Semaforo Passadeira Verde\r\n";
  21          char code passadeiraAmarelo[] = "Semaforo Passadeira Amarelo\r\n";
  22          char code passadeiraVermelho[] = "Semaforo Passadeira Vermelho\r\n";
  23          
  24          
  25          char code intermitente[] = "Semaforo Estrada Intermitente\r\n";
  26          char code inicio[] = "Semaforo estrada sempre verde, passdeira só fica verde quando o PB1 é pressionado\r\
             -n";
  27          
  28          char numeros[][3] = {"0","1", "2", "3", "4", "5", "6", "7", "8", "9"};
  29          
  30          
  31          unsigned char digits_array[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
  32          
  33          
  34          /*********************************************************/
  35          typedef enum ENUM_STATES {S1 = 0, S2} e_states;
  36          
  37          e_states state, nextstate;
  38          
  39          /* function prototypes */
  40          void state_1 (void);
  41          void state_2 (void);
  42          
  43          //DEBOUNCE
  44          unsigned int debounce(bit PB){
  45   1              char window;  
  46   1              unsigned int j;
  47   1          for(j = 0; j < 8; j++) {
  48   2              window = (window << 1) | PB;
  49   2          }
  50   1          return window;
  51   1      }
  52          
  53          void transmitString(const char *str) {
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     01/07/2024 21:18:11 PAGE 2   

  54   1          const char *ptr = str;
  55   1          
  56   1          while (*ptr != '\0') {
  57   2              while (uart0_putchar(*ptr) == -ENOBUFS);
  58   2              ++ptr;
  59   2          }
  60   1      }
  61          void esperarPassadeira(){
  62   1        char i;
  63   1        for (i = 10; i >= 0; --i) {
  64   2            transmitString(numeros[i]);
  65   2            if (i < 10) {
  66   3                transmitString("...\n");
  67   3              if (i == 5){
  68   4                transmitString(estradaAmarelo);
  69   4              }
  70   3            }
  71   2            transmitString(estradaVermelho);
  72   2            transmitString(passadeiraVerde);
  73   2        }
  74   1      }
  75          void temporizador(){
  76   1        
  77   1        char i;
  78   1        for (i = 10; i >= 0; --i) {
  79   2            P2 = digits_array[i];
  80   2            transmitString(numeros[i]);
  81   2            if (i < 10) {
  82   3                transmitString("...\n");
  83   3            }
  84   2        }
  85   1      }
  86          
  87          void temporizadorPassadeira(){
  88   1        char i;
  89   1        for (i = 10; i >= 0; --i) {
  90   2            P2 = digits_array[i];
  91   2            transmitString(numeros[i]);
  92   2            if (i < 10) {
  93   3                transmitString("...\n");
  94   3            if (i == 5){
  95   4              transmitString(passadeiraAmarelo);
  96   4            }
  97   3            }
  98   2            delay_s(1);
  99   2            transmitString(passadeiraVermelho);
 100   2        }
 101   1      }
 102          
 103          void butaopassadeira(){
 104   1        if(debounce(!PB1) && !button1pressed) {
 105   2          
 106   2          transmitString("Passadeira ficará verde em 10 segundos\r\n");
 107   2          temporizador();
 108   2          transmitString(passadeiraVerde);
 109   2          transmitString("Tens 10 segundos para passar...\r\n");
 110   2          temporizadorPassadeira();
 111   2          delay_s(1);
 112   2          transmitString(estradaVerde);
 113   2          
 114   2          button1pressed = 1;               
 115   2          } 
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     01/07/2024 21:18:11 PAGE 3   

 116   1            if(!debounce(!PB1)){ // reset a flag se o botao ? clicado
 117   2              button1pressed = 0;
 118   2            }
 119   1        
 120   1      }
 121          
 122          void EsteOeste(){
 123   1        temporizador();
 124   1        nextstate = S1;
 125   1      }
 126          /*********************************************************/ 
 127          void (*state_process [])(void) = {state_1, state_2};
 128          
 129          
 130          void state_1(void){
 131   1        butaopassadeira();
 132   1      }
 133          void state_2(void){
 134   1        
 135   1      }
 136          
 137          /*********************************************************/
 138          void encode_FSM(){
 139   1          state_process[state] ();
 140   1      }
 141          
 142          /*********************************************************
 143           *    main function                                      *
 144           *********************************************************/
 145          void main (void){
 146   1        
 147   1        
 148   1        Init_Device();
 149   1        uart0_initialize();
 150   1        timer2_init_auto(-40000);
 151   1      
 152   1        //Set by hardware when the Timer 2 high byte overflows from 0xFF to 0x00. In 16 bit 
 153   1        //mode, this will occur when Timer 2 overflows from 0xFFFF to 0x0000.   
 154   1        TF2H = 0; 
 155   1        // Enable Flag Timer 2 Overflow
 156   1        // Timer 2 Run Control. Timer 2 is enabled by setting this bit to 1. 
 157   1        TR2 = 1;
 158   1        
 159   1        
 160   1        EA=1;
 161   1        
 162   1        state = nextstate = S1;
 163   1        delay_s(1);
 164   1        transmitString(inicio);
 165   1        
 166   1        while (1) {
 167   2          
 168   2          encode_FSM();
 169   2          state = nextstate;
 170   2          
 171   2        }
 172   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    516    ----
   CONSTANT SIZE    =    365    ----
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     01/07/2024 21:18:11 PAGE 4   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     64    ----
=======
  16          
  17          unsigned char digits_array[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
  18          
  19          
  20          /*********************************************************/
  21          typedef enum ENUM_STATES {S1 = 0, S2} e_states;
  22          
  23          e_states state, nextstate;
  24          
  25          /* function prototypes */
  26          void state_1 (void);
  27          void state_2 (void);
  28          
  29          void temporizador(){
  30   1        char i;
  31   1        for (i = 9; i >= 0; --i) {
  32   2            P2 = digits_array[i];
  33   2            delay_s(1);
  34   2            nextstate = S2;
  35   2        }
  36   1        for(ptr = (char code*)sentidoNorteSul; *ptr!= '\0'; ptr++){
  37   2          while(uart0_putchar(*ptr)== -ENOBUFS);
  38   2        }
  39   1      }
  40          
  41          void NorteSul(){
  42   1      
  43   1        
  44   1      //print_u0(sentidoNorteSul);
  45   1        
  46   1        temporizador();
  47   1      }
  48          
  49          void EsteOeste(){
  50   1        temporizador();
  51   1        nextstate = S1;
  52   1      }
  53          /*********************************************************/ 
  54          
C51 COMPILER V9.60.7.0   STATE_MACHINE                                                     01/07/2024 17:39:18 PAGE 2   

  55          void (*state_process [])(void) = {state_1, state_2};
  56          
  57          
  58          void state_1(void){
  59   1        NorteSul();
  60   1      }
  61          void state_2(void){
  62   1        
  63   1      }
  64          
  65          /*********************************************************/
  66          void encode_FSM(){
  67   1          state_process[state] ();
  68   1      }
  69          
  70          /*********************************************************
  71           *    main function                                      *
  72           *********************************************************/
  73          void main (void){
  74   1        
  75   1        
  76   1        Init_Device();
  77   1        uart0_initialize();
  78   1        timer2_init_auto(-40000);
  79   1      
  80   1        //Set by hardware when the Timer 2 high byte overflows from 0xFF to 0x00. In 16 bit 
  81   1        //mode, this will occur when Timer 2 overflows from 0xFFFF to 0x0000.   
  82   1        TF2H = 0; 
  83   1        // Enable Flag Timer 2 Overflow
  84   1        // Timer 2 Run Control. Timer 2 is enabled by setting this bit to 1. 
  85   1        TR2 = 1;
  86   1        
  87   1        EA=1;
  88   1        
  89   1        state = nextstate = S1;
  90   1        
  91   1        while (1) {
  92   2          
  93   2          encode_FSM();
  94   2          state = nextstate;
  95   2          
  96   2        }
  97   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    157    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     21    ----
>>>>>>> parent of a1d659e (falta fazer, tudo a funcionar)
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
