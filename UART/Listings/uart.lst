C51 COMPILER V9.60.7.0   UART                                                              11/10/2023 20:58:24 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE uart.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\uart
                    -.lst) TABS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include <REG51F380.H>
   2          #include "init_device.h"
   3          #include <string.h>
   4          #include <stdio.h>
   5          #include "config_platform.h"
   6          #include "serialIO.h"
   7          
   8          #define B_TF3H 7
   9          #define B_TR3 2
  10          #define B_ET3 7
  11          
  12          sbit pb1 = P0^6;
  13          sbit pb2 = P0^7;
  14          
  15          //chave por defeito               8     0     5     1
  16          unsigned char default_key[4] = {0x80, 0xC0, 0x92, 0xF9};
  17           
  18          //                                  L     0     1     2     3     4     5     6     7     8     9
  19          unsigned char digits_array[11] = {0xC7, 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
  20          
  21          
  22          unsigned char button1pressed; //flags se os botoes sao clicados
  23          unsigned char button2pressed;
  24          unsigned char wrongkeycount;
  25          
  26           
  27          
  28          /*********************************************************/
  29          typedef enum ENUM_STATES {S1 = 0, S2, S3, S4, S5} e_states;
  30          
  31          e_states state, nextstate;
  32          
  33          /* function prototypes */
  34          void state_1(void);
  35          void state_2(void);
  36          void state_3(void);
  37          void state_4(void);
  38          void state_5(void);
  39          
  40          
  41          /*********************************************************
  42           * uart0 init                                            *
  43           *********************************************************/
  44          void uart0_init(void){  
  45   1          /* UART0 Control                            */
  46   1          /* set REN0, enable reception               */
  47   1          SCON0     = 0x10;
  48   1        
  49   1          /* Timer/Counter Mode                       */  
  50   1          TMOD      = 0x20;
  51   1        
  52   1          /* Clock Control                            */
  53   1          CKCON     = 0x08;
  54   1        
C51 COMPILER V9.60.7.0   UART                                                              11/10/2023 20:58:24 PAGE 2   

  55   1          /* Timer/Counter 1 High                     
  56   1           * 0x30 generates a baudrate of 115200 bps  */
  57   1          TH1       = 0x30;
  58   1        
  59   1          /* Timer 1 On/Off Control                   */
  60   1          TR1       = 1;
  61   1        
  62   1          /* UART0 TX Interrupt Flag                  */
  63   1          TI0       = 1;
  64   1          RI0 = 1;
  65   1      }
  66          
  67          
  68          /*********************************************************
  69           * getc using uart0                                      *
  70           *********************************************************/
  71          char uart0_getc(char* c){
  72   1      
  73   1        if(RI0 == 1){
  74   2          RI0 = 0;
  75   2          *c = SBUF0; 
  76   2          return 1;
  77   2        }
  78   1        return 0;
  79   1      }
  80          
  81          
  82          void timer3_init_auto(char reload){
  83   1      
  84   1        TMR3CN = 0;
  85   1      
  86   1        #define B_T3MH 7  
  87   1      
  88   1        CKCON &= ~((1 << B_T3MH));
  89   1        
  90   1        TMR3H = (reload) >> 8;
  91   1        TMR3L = (reload);
  92   1      
  93   1        TMR3RLH = (reload) >> 8;
  94   1        TMR3RLL = (reload);
  95   1        
  96   1      }
  97          
  98          
  99          void timer2_init_auto(char reload){
 100   1      
 101   1        TMR2CN = 0;
 102   1      
 103   1        #define B_T2MH 5  
 104   1      
 105   1        CKCON &= ~((1 << B_T2MH));
 106   1        
 107   1        TMR2H = (reload) >> 8;
 108   1        TMR2L = (reload);
 109   1      
 110   1        TMR2RLH = (reload) >> 8;
 111   1        TMR2RLL = (reload);
 112   1        
 113   1      }
 114          
 115          void delay_250us(){
 116   1        while(!(TMR3CN & (1 << B_TF3H)));
C51 COMPILER V9.60.7.0   UART                                                              11/10/2023 20:58:24 PAGE 3   

 117   1        TMR3CN &= ~(1 << B_TF3H);  
 118   1      }
 119          
 120          void delay_s(unsigned char s) {
 121   1          unsigned char i = 0;
 122   1      
 123   1          while(i != (s*100)) {
 124   2              i++;
 125   2              while(!TF2H);
 126   2              TF2H = 0;
 127   2          }
 128   1      }
 129          
 130          
 131          void square_wave(){
 132   1        while (1){ // mudar para aceitar a HWFLAG
 133   2          //HIGH
 134   2          P1 |= 0x80;
 135   2          delay_250us();
 136   2          //LOW
 137   2          P1 &= ~(0x80);
 138   2          delay_250us();
 139   2        }
 140   1      }
 141          
 142          // validar a key introduzida pelo utilizador
 143          bit validate_key(unsigned char v1[4], unsigned char v2[4]){
 144   1        return memcmp(v1, v2, 4) == 0;
 145   1      }
 146          
 147          //DEBOUNCE
 148          unsigned char debounce(bit PB){
 149   1              char window = 0;  
 150   1              unsigned char j;
 151   1          for(j = 0; j < 8; j++) {
 152   2              window = (window << 1) | PB;
 153   2          }
 154   1          return window;
 155   1      }
 156          
 157          // ler a key a ser posta pelo utilizador
 158          void read_key(){
 159   1          unsigned char digit_index;      //index dos digitos
 160   1          unsigned char index_input_key;  //index da key a ser lida
 161   1          unsigned char input_key[4];
 162   1          unsigned char teste_key[4] = {0x38, 0x30, 0x35, 0x31};
 163   1          unsigned char c = 0;
 164   1          while(!uart0_getc(&c)){
 165   2          }
 166   1        
 167   1        if(c==0x2D){ //caracter -
 168   2            printf("decrementar\n");
 169   2            
 170   2            if(digit_index > 11) {
 171   3              digit_index--;
 172   3            }
 173   2            
 174   2            if(digit_index < 10) {
 175   3            
 176   3            }
 177   2        }
 178   1          
C51 COMPILER V9.60.7.0   UART                                                              11/10/2023 20:58:24 PAGE 4   

 179   1      
 180   1        if(c == 0x45){ // caracter E 
 181   2            printf("enter\n");
 182   2            input_key[index_input_key] = digits_array[digit_index];
 183   2            index_input_key++;
 184   2            digit_index = 0;
 185   2          }
 186   1        
 187   1          if(index_input_key == 4){
 188   2            if(validate_key(input_key,default_key)){
 189   3              index_input_key = 0;
 190   3              wrongkeycount = 0;
 191   3              nextstate = S2;
 192   3            }
 193   2            else{
 194   3              index_input_key = 0;
 195   3              nextstate = S3;
 196   3            }
 197   2          }
 198   1      
 199   1          
 200   1          if(c == 0x2b) { // caracter +
 201   2            printf("incremento\n");
 202   2            
 203   2            if (digit_index < 11) {
 204   3              digit_index++;
 205   3            }
 206   2            if (digit_index > 10){
 207   3              digit_index = 0;
 208   3            }
 209   2          }
 210   1      
 211   1          P2 = digits_array[digit_index];
 212   1      }
 213          
 214          void errorhandling(){
 215   1          wrongkeycount++;
 216   1          if(wrongkeycount == 1){
 217   2            P2 = 0x86; // E
 218   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 4
             - segundos num total de 5 segundos
 219   2            P2 = 0xC6; // C
 220   2            delay_s(4);//wait 4 secs
 221   2            nextstate = S1;
 222   2          }
 223   1          if(wrongkeycount == 2){
 224   2            P2 = 0x86; // E
 225   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 9
             - segundos
 226   2            P2 = 0xC6; // C
 227   2            delay_s(9);//wait 9 secs
 228   2            nextstate = S1;
 229   2          }
 230   1          if(wrongkeycount == 3){
 231   2            P2 = 0x86; // E
 232   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 1
             -4 segundos
 233   2            P2 = 0xC6; // C
 234   2            delay_s(14);//wait 14 secs
 235   2            nextstate = S1;
 236   2          }
 237   1          if(wrongkeycount == 4){
C51 COMPILER V9.60.7.0   UART                                                              11/10/2023 20:58:24 PAGE 5   

 238   2            P2 = 0x86; // E
 239   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 1
             -9 segundos
 240   2            P2 = 0xC6; // C
 241   2            delay_s(19);//wait 19 secs
 242   2            nextstate = S1;
 243   2          }
 244   1          if(wrongkeycount == 5){
 245   2            nextstate = S4;
 246   2          }
 247   1      }
 248          
 249          void open_menu(){//                 O       P     C
 250   1          unsigned char open_menu[3] = {0xA3 , 0x8C, 0xC6};
 251   1          unsigned char index;
 252   1          char c = 0;
 253   1          
 254   1          
 255   1          if(uart0_getc(&c) == 0x45){
 256   2            if(open_menu[index] == 0x8C){
 257   3              nextstate = S5;
 258   3              index = 0;
 259   3            }
 260   2            if(open_menu[index] == 0xC6){
 261   3              nextstate = S1;
 262   3              index = 0;
 263   3            }
 264   2          }
 265   1          
 266   1          
 267   1          if(uart0_getc(&c) == 0x2b){
 268   2            
 269   2            
 270   2            button1pressed = 1;            
 271   2            if (index < 3){
 272   3              index++;
 273   3            }
 274   2            if (index > 2){
 275   3              index = 0;
 276   3            }
 277   2          }
 278   1          
 279   1      
 280   1      
 281   1          P2 = open_menu[index];
 282   1        
 283   1      }
 284          void set_key(){//                 P     0     1     2     3     4     5     6     7     8     9
 285   1          unsigned char set_key[11] = {0x8C, 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
 286   1          unsigned char index;
 287   1          unsigned char index_new_key;
 288   1          char c = 0;
 289   1          
 290   1          if(uart0_getc(&c) == 0x45){
 291   2            default_key[index_new_key] = set_key[index];
 292   2            index_new_key++;
 293   2            index = 0;
 294   2          }
 295   1          
 296   1          if(index_new_key == 4){
 297   2            index_new_key = 0;
 298   2            nextstate = S1;
C51 COMPILER V9.60.7.0   UART                                                              11/10/2023 20:58:24 PAGE 6   

 299   2          }
 300   1          
 301   1          
 302   1          if(uart0_getc(&c) == 0x2b){
 303   2                       
 304   2            if (index < 11){
 305   3              index++;
 306   3            }
 307   2            if (index > 10){
 308   3              index = 0;
 309   3            }
 310   2          }
 311   1          
 312   1      
 313   1          P2 = set_key[index];
 314   1      }
 315          
 316          
 317          /*********************************************************/ 
 318          //                          close/locked    open    error     alarm   set_key
 319          void (*state_process [])(void) = {state_1, state_2, state_3, state_4, state_5};
 320          
 321          
 322          void state_1(void){
 323   1          read_key();
 324   1          P1 = 0x10;
 325   1      }
 326          void state_2(void){
 327   1          open_menu();
 328   1          P1 &= ~(0x10);
 329   1      }
 330          void state_3(void){
 331   1          errorhandling();
 332   1      }
 333          void state_4(void){
 334   1          P2 = 0x88;
 335   1          square_wave();
 336   1      }
 337          void state_5(void){
 338   1          set_key();
 339   1      }
 340          
 341          /*********************************************************/
 342          void encode_FSM(){
 343   1          state_process[state] ();
 344   1      }
 345          
 346          /*********************************************************/
 347          
 348          
 349          /*********************************************************
 350           *    main function                                      *
 351           *********************************************************/
 352          void main (void){
 353   1        
 354   1        Init_Device();
 355   1        uart0_init(); 
 356   1        
 357   1        timer2_init_auto(-40000);
 358   1        timer3_init_auto(-1000);
 359   1        
 360   1        state = nextstate = S1;
C51 COMPILER V9.60.7.0   UART                                                              11/10/2023 20:58:24 PAGE 7   

 361   1        
 362   1        printf("uart a funcionar");
 363   1        
 364   1        //Set by hardware when the Timer 2/3 high byte overflows from 0xFF to 0x00. In 16 bit 
 365   1        //mode, this will occur when Timer 2/3 overflows from 0xFFFF to 0x0000.   
 366   1        TF2H = 0; 
 367   1        TMR3CN &= ~(1 << B_TF3H);
 368   1        
 369   1        // Enable Flag Timer 2/3 Overflow
 370   1        ET2 = 1;
 371   1        EIE1 |= (1 << B_ET3);
 372   1        
 373   1        // Timer 2/3 Run Control. Timer 2/3 is enabled by setting this bit to 1. 
 374   1        TMR3CN |= (1 << B_TR3);
 375   1        TR2 = 1;
 376   1            
 377   1        char c = 0;
*** ERROR C141 IN LINE 377 OF uart.c: syntax error near 'char', expected '__asm'
*** ERROR C202 IN LINE 377 OF uart.c: 'c': undefined identifier
 378   1        char code *ptr;
*** ERROR C141 IN LINE 378 OF uart.c: syntax error near 'char', expected '__asm'
*** ERROR C202 IN LINE 378 OF uart.c: 'ptr': undefined identifier
 379   1        Init_Device();
 380   1        uart0_initialize();
 381   1        EA=1;
 382   1          
 383   1        for(ptr = (char code*)message0; *ptr!= '\0'; ptr++){
*** ERROR C202 IN LINE 383 OF uart.c: 'ptr': undefined identifier
 384   2          while(uart0_putchar(*ptr)== -ENOBUFS);
*** ERROR C202 IN LINE 384 OF uart.c: 'ptr': undefined identifier
 385   2        }
 386   1        
 387   1        printf(message1);   
*** ERROR C202 IN LINE 387 OF uart.c: 'message1': undefined identifier
 388   1            
 389   1            
 390   1        while (1) {
 391   2          encode_FSM();
 392   2          state = nextstate;
 393   2        }
 394   1        
 395   1        
 396   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  7 ERROR(S)
