C51 COMPILER V9.60.0.0   GUIA1_B                                                           11/18/2020 13:44:40 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE GUIA1_B
OBJECT MODULE PLACED IN .\Objects\guia1-b.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE guia1-b.c OPTIMIZE(0,SPEED) BROWSE NOAREGS DEBUG OBJECTEXTEND PRINT(.\Li
                    -stings\guia1-b.lst) TABS(2) OBJECT(.\Objects\guia1-b.obj)

line level    source

   1          #include <REG51F380.H>
   2          #include <stdio.h>
   3          #include "types.h"
   4          
   5          #define SCON1_RI1 (1U << 0)
   6          #define SCON1_TI1 (1U << 1)
   7          #define SCON1_REN1 (1U << 4)
   8          
   9          /* Choose a UART */
  10          #define UART_IN_USE 0
  11          
  12          /*********************************************************
  13           * function prototypes                                   *
  14           *********************************************************/
  15          void uart0_init(void);
  16          void uart1_init(void);
  17          void print_u0(char* p_message);
  18          void print_u1(char* p_message);
  19          char uart0_getc(char* c);
  20          void uart0_putc(char c);
  21          char uart1_getc(char* c);
  22          void uart1_putc(char c);
  23          
  24          /*********************************************************/
  25          
  26          /* P2 = 0xA0 */
  27          sbit seg_dp = P2^7;
  28          sbit PB1  = P0^6;
  29          sbit PB2  = P0^7;
  30          
  31          bit pb1, pb2, pb1_p, pb2_p = 1;
  32          
  33            /*  force this string to be stored in the 
  34                program memory. program (CODE) memory 
  35                is read-only.                           */
  36          code char message_u0[] = "Hello World UART0\r\n";
  37          code char message_u1[] = "Hello World UART1\r\n";
  38          
  39          code const char seg[] = { ~0x3F, ~0x06, ~0x5B, ~0x4F, ~0x66, ~0x6D, ~0x7D, ~0x07, ~0x7F, ~0x67 };
  40          code const int seg_size = sizeof(seg)/sizeof(char);
  41            
  42          uint8_t index = 0;
  43            
  44          /* Timer2 and debounce */
  45          // put vars here  
  46          static int blink = 100;
  47          
  48          #define INTMAX 32
  49          unsigned char integrator_PB1 = 0;
  50          unsigned char integrator_PB2 = 0;
  51          bit outPB1, outPB2;
  52            
  53          /*********************************************************/ 
  54          void Oscillator_Init(void){
C51 COMPILER V9.60.0.0   GUIA1_B                                                           11/18/2020 13:44:40 PAGE 2   

  55   1         PCA0MD    &= ~0x40;
  56   1         PCA0MD    = 0x00;
  57   1         FLSCL     = 0x90;
  58   1         CLKSEL    = 0x03;
  59   1      }
  60          /*********************************************************/
  61          /* timer2 init code here */
  62          
  63          void timer2_init_auto(int reload){
  64   1      
  65   1      //SFR Definition 25.9. TMR2CN: Timer 2 Control
  66   1      //---------------------------------------------------------------
  67   1      //Bit |  7   |   6  |   5    |  4    |  3     | 2   |   1  |  0
  68   1      //---------------------------------------------------------------
  69   1      //Name| TF2H | TF2L | TF2LEN |TF2CEN |T2SPLIT | TR2 |T2CSS |T2XCLK
  70   1      //---------------------------------------------------------------
  71   1        // sysclock /12
  72   1        TMR2CN = 0;
  73   1      
  74   1      #define B_T2MH 5  
  75   1      //SFR Definition 25.1. CKCON: Clock Control
  76   1      //-------------------------------------------------------------
  77   1      //Bit |  7   |   6  |   5  |  4  |  3 | 2   |   1  |  0
  78   1      //-------------------------------------------------------------
  79   1      //Name| T3MH | T3ML | T2MH |T2ML |T1M | T0M |   SCA[1:0]
  80   1      //------------------------------------------------------------- 
  81   1        
  82   1        //Timer 2 high byte T2MH and low byte T2ML use the system clock
  83   1        CKCON &= ~((1 << B_T2MH));
  84   1        
  85   1        TMR2H = (reload) >> 8;
  86   1        TMR2L = (reload);
  87   1      
  88   1        TMR2RLH = (reload) >> 8;
  89   1        TMR2RLL = (reload);
  90   1      
  91   1      }
  92          
  93          /*********************************************************/
  94          /* timer 2 isr code here */
  95          void timer2_isr(void) interrupt 5 using 2
  96          {
  97   1        // sysclock /12 = 4MHz
  98   1        // 1s 4,000,000 ticks!
  99   1        // 10ms => 40000 ticks!
 100   1        
 101   1        if(--blink == 0){
 102   2          seg_dp ^= 1;
 103   2          blink = 100;
 104   2        }
 105   1      
 106   1        //implementar debounce!!
 107   1        if(PB1 == 0){
 108   2          if(integrator_PB1 > 0)
 109   2            integrator_PB1--;
 110   2        } else { //PB1 == 1
 111   2          if(integrator_PB1 < INTMAX)
 112   2            integrator_PB1++;
 113   2        }
 114   1        
 115   1        if(integrator_PB1 == 0){
 116   2          outPB1 = 0;
C51 COMPILER V9.60.0.0   GUIA1_B                                                           11/18/2020 13:44:40 PAGE 3   

 117   2        } else if(integrator_PB1 >= INTMAX){
 118   2          outPB1 = 1;
 119   2          integrator_PB1 = INTMAX;
 120   2        }
 121   1        
 122   1        if(PB2 == 0){
 123   2          if(integrator_PB2 > 0)
 124   2            integrator_PB2--;
 125   2        } else { //PB1 == 1
 126   2          if(integrator_PB2 < INTMAX)
 127   2            integrator_PB2++;
 128   2        }
 129   1        
 130   1        if(integrator_PB2 == 0){
 131   2          outPB2 = 0;
 132   2        } else if(integrator_PB2 >= INTMAX){
 133   2          outPB2 = 1;
 134   2          integrator_PB2 = INTMAX;
 135   2        }
 136   1          
 137   1        TF2H = 0; 
 138   1      }
 139          /*********************************************************
 140           * my main loop                                          *
 141           *********************************************************/
 142          void main (void){
 143   1        
 144   1        // index value, key/uard read value, temp value to calculate table value 
 145   1        int ind = 0, val = 0, temp = 0;
 146   1        
 147   1        // push buttons pressed
 148   1        bit pb1, pb2, pb1_prev = 1, pb2_prev = 1;
 149   1        
 150   1        // received/transmitted  char
 151   1        char c = 0; 
 152   1        
 153   1        Oscillator_Init(); 
 154   1        
 155   1      #if UART_IN_USE == 0
 156   1        uart0_init();
 157   1        print_u0(message_u0);
 158   1      #elif UART_IN_USE == 1
                uart1_init();
                print_u1(message_u1);
              #elif
              #error uart is required!
              #endif
 164   1      
 165   1        timer2_init_auto(-40000);
 166   1      
 167   1        //Set by hardware when the Timer 2 high byte overflows from 0xFF to 0x00. In 16 bit 
 168   1        //mode, this will occur when Timer 2 overflows from 0xFFFF to 0x0000.   
 169   1        TF2H = 0;
 170   1        
 171   1        // Enable Flag Timer 2 Overflow
 172   1        ET2 = 1;
 173   1      
 174   1        // Timer 2 Run Control. 
 175   1        // Timer 2 is enabled by setting this bit to 1. 
 176   1        TR2 = 1;
 177   1      
 178   1        // Enable All Interrupts.
C51 COMPILER V9.60.0.0   GUIA1_B                                                           11/18/2020 13:44:40 PAGE 4   

 179   1        EA = 1; 
 180   1        
 181   1        while(1){
 182   2      
 183   2          //sample buttons
 184   2          pb1 = PB1; //outPB1; //PB1;
 185   2          pb2 = PB2; //outPB2; //PB2;
 186   2          
 187   2          //detect negedge
 188   2          if(pb1_prev && (pb1_prev ^ pb1))
 189   2            val +=1;  
 190   2          if(pb2_prev && (pb2_prev ^ pb2))
 191   2            val -=1;
 192   2      
 193   2          //save last read value
 194   2          pb1_prev = pb1;
 195   2          pb2_prev = pb2;
 196   2          //check if i or d char was received 
 197   2          if(uart0_getc(&c)){
 198   3            switch(c) {
 199   4              case 'i':
 200   4              case 'I':
 201   4                val += 1;
 202   4                break;
 203   4              case 'd':
 204   4              case 'D':
 205   4                val -= 1;
 206   4                break;
 207   4            }
 208   3            c = 0;
 209   3          }
 210   2        
 211   2          if(val){      
 212   3            temp = ind + val;
 213   3            if(temp >= seg_size) temp = seg_size-1;
 214   3            else if(temp < 0) temp = 0;
 215   3            val = 0;
 216   3            
 217   3            if(ind != temp){
 218   4              ind = temp;
 219   4              P2 = seg[ind];
 220   4              uart0_putc(ind + 0x30);
 221   4              print_u0("\r");
 222   4            }
 223   3          }   
 224   2        }
 225   1      }
 226          
 227          /*********************************************************
 228           * uart0 init                                            *
 229           *********************************************************/
 230          #if UART_IN_USE == 0
 231          void uart0_init(void){  
 232   1          XBR0      = 0x01;
 233   1          XBR1      = 0x40;
 234   1          SCON0     = 0x10;
 235   1          TMOD      = 0x20;
 236   1          CKCON     = 0x08;
 237   1          TH1       = 0x30;
 238   1          TR1       = 1;
 239   1          TI0       = 1;
 240   1      }
C51 COMPILER V9.60.0.0   GUIA1_B                                                           11/18/2020 13:44:40 PAGE 5   

 241          /*********************************************************
 242           * print using uart0                                     *
 243           *********************************************************/
 244          void print_u0(char* p_message){
 245   1        
 246   1        unsigned char i = 0;
 247   1        
 248   1        while(p_message[i] != 0){
 249   2          
 250   2          // Transmission interrupt flag
 251   2          while(TI0 == 0);
 252   2          
 253   2          // UART write/read buffer (1 byte)
 254   2          SBUF0 = p_message[i];
 255   2          
 256   2          // Transmission flag control. set by hardware.
 257   2          TI0 = 0;
 258   2          i++;
 259   2        }
 260   1      }
 261          
 262          /*********************************************************
 263           * putc using uart0                                      *
 264           *********************************************************/
 265          void uart0_putc(char c){
 266   1        
 267   1        while(TI0 == 0);
 268   1        TI0 = 0;
 269   1        SBUF0 = c;
 270   1        
 271   1      }
 272          
 273          /*********************************************************
 274           * getc using uart0                                      *
 275           *********************************************************/
 276          char uart0_getc(char* c){
 277   1      
 278   1        if(RI0 != 0){
 279   2          RI0 = 0;
 280   2          *c = SBUF0; 
 281   2          return 1;
 282   2        }
 283   1        return 0;
 284   1      }
 285          #endif
 286          /*********************************************************
 287           * uart1 init                                            *
 288           *********************************************************/
 289          #if UART_IN_USE == 1
              void uart1_init(){
              
                XBR1      = 0x40;
                
                P0SKIP |= 0x0F; //skip P0'S 0 to 3 so that uart1 is in pins 4 P0.4 and P0.5
                XBR2 |= 0x01; //enable uart1 pins in xbar
                
                //set uart1 baudrate to 115200
                SCON1     = 0x10;
                SBRLL1    = 0x30;
                SBRLH1    = 0xFF;
                SBCON1    = 0x43;
                
C51 COMPILER V9.60.0.0   GUIA1_B                                                           11/18/2020 13:44:40 PAGE 6   

                //enable uart reception ans set transmit flag to signal output buffer is empty
                SCON1     = 0x10 | SCON1_TI1;
              }
              
              /*********************************************************
               * print using uart1                                     *
               *********************************************************/
              void print_u1(char* p_message){
                
              unsigned char *ptr = p_message;
                
                  while(*ptr) 
                    uart1_putc(*ptr++); 
              }
              
              /*********************************************************
               * getc using uart1                                      *
               *********************************************************/
              char uart1_getc(char* c){
              
                if(SCON1 & SCON1_RI1){
                  *c = SBUF1; 
                  SCON1 &= ~SCON1_RI1;
                  return 1;
                }
                return 0;
              }
              
              /*********************************************************
               * putc using uart1                                      *
               *********************************************************/
              void uart1_putc(char c){
                
                while(!(SCON1 & SCON1_TI1));
                SCON1 &= ~SCON1_TI1;
                
                SBUF1 = c;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    668    ----
   CONSTANT SIZE    =     54    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     22    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     10    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
