C51 COMPILER V9.60.7.0   SERIALIO                                                          12/28/2023 16:26:10 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SERIALIO
OBJECT MODULE PLACED IN .\Objects\serialIO.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE serialIO.c OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\
                    -serialIO.lst) TABS(2) OBJECT(.\Objects\serialIO.obj)

line level    source

   1          #include <REG51F380.H>
   2          #include "serialIO.h"
   3          #include <string.h>
   4          
   5          /*------------------------------------------------------------------------------
   6          Notes:
   7          The length of the receive and transmit buffers must be a power of 2.
   8          
   9          Each buffer has a WriteIndex and a ReadIndex.
  10          
  11          If WriteIndex = ReadIndex, the buffer is empty.
  12          
  13          (ReadIndex -WriteIndex)% buffer_size = the number of characters in the buffer.
  14          ------------------------------------------------------------------------------*/
  15          
  16          #define TBUF_SIZE   16           // Must be a power of 2 AND 2 <= SIZE <= 128
  17          #define RBUF_SIZE   16           // Must be a power of 2 AND 2 <= SIZE <= 128
  18          
  19          
  20          static unsigned char pdata TxBuff [TBUF_SIZE];
  21          static unsigned char pdata RxBuff [RBUF_SIZE];
  22          
  23          static volatile unsigned char TxWriteIndex = 0;
  24          static volatile unsigned char TxReadIndex = 0;
  25          
  26          static volatile unsigned char RxWriteIndex = 0;
  27          static volatile unsigned char RxReadIndex = 0;
  28          
  29          static bit ti_restart = 1;  /* Not Zero if TI = 1 is required */
  30          
  31          /*------------------------------------------------------------------------------
  32          ------------------------------------------------------------------------------*/
  33          void uart0_isr (void) interrupt 4
  34          {
  35   1        /*------------------------------------------------
  36   1        Received data interrupt.
  37   1        ------------------------------------------------*/
  38   1        if (RI0 != 0)
  39   1        {
  40   2          RI0 = 0;
  41   2            //is there space left?
  42   2          if (((RxWriteIndex - RxReadIndex) & ~(RBUF_SIZE-1)) == 0)
  43   2          {
  44   3            RxBuff [RxWriteIndex & (RBUF_SIZE-1)] = SBUF0;
  45   3            RxWriteIndex++;
  46   3          }
  47   2        }
  48   1      
  49   1        /*------------------------------------------------
  50   1        Transmitted data interrupt.
  51   1        ------------------------------------------------*/
  52   1        if (TI0 != 0)
  53   1        {
  54   2          
C51 COMPILER V9.60.7.0   SERIALIO                                                          12/28/2023 16:26:10 PAGE 2   

  55   2          //is there any byte to send?
  56   2          if (TxWriteIndex != TxReadIndex)
  57   2          {
  58   3            SBUF0 = TxBuff [TxReadIndex & (TBUF_SIZE-1)];
  59   3            TxReadIndex++;
  60   3            ti_restart = 0;
  61   3          }
  62   2          else //subsequent insertion in buffer tbuf will require
  63   2             // TI to be set to 1 so that machine starts to pump bytes again
  64   2            ti_restart = 1;
  65   2          TI0 = 0;
  66   2        }
  67   1      
  68   1      }
  69          
  70          /*------------------------------------------------------------------------------
  71          ------------------------------------------------------------------------------*/
  72          #pragma disable
  73          void uart0_initialize (void)
  74          {
  75   1        
  76   1      //---------------------------------------------------------
  77   1      //  XBR0: Port I/O Crossbar Register 0
  78   1      //---------------------------------------------------------
  79   1      //  7   |   6   |   5   |   4  |  3   |   2  |  1   | 0   |
  80   1      //---------------------------------------------------------
  81   1      // CP1AE| CP1E  | CP0AE | CP0E |SYSCKE| SMB0E| SPI0E|URT0E|
  82   1      //---------------------------------------------------------
  83   1      #define B_URT0E 0
  84   1        XBR0      = (1<<B_URT0E) ;  
  85   1        
  86   1        //---------------------------------------------------------
  87   1      //   SCON0: Serial Port 0 Control
  88   1      //---------------------------------------------------------
  89   1      //  7   |   6   |   5   |   4  |  3   |   2  |  1   | 0   |
  90   1      //---------------------------------------------------------
  91   1      //S0MODE|   -   | MCE0  | REN0 | TB80 | RB80 | TI0  | RI0 |
  92   1      //---------------------------------------------------------
  93   1      #define B_REN0 4
  94   1        
  95   1        SCON0= 0;
  96   1        SCON0 |=(1<<B_REN0);
  97   1            
  98   1      //---------------------------------------------------------
  99   1      //   CKCON: Clock Control
 100   1      //---------------------------------------------------------
 101   1      //  7   |   6   |   5   |   4  |  3   |   2  |  1   | 0   |
 102   1      //---------------------------------------------------------
 103   1      // T3MH | T3ML  | T2MH  | T2ML | T1M  | T0M  |   SCA[1:0]
 104   1      //---------------------------------------------------------
 105   1      #define B_T1M 3
 106   1      #define B_SCA1 1
 107   1      #define B_SCA0 0
 108   1        
 109   1        //CKCON     = 0x08;//  clock is prescaled by sca[1:0] = 0 => sysclk/12
 110   1        CKCON &=~((1<<B_SCA1)|(1<<B_SCA0));
 111   1        CKCON |= (1<<B_T1M);
 112   1        
 113   1        //---------------------------------------------------------
 114   1      //   TMOD:
 115   1      //---------------------------------------------------------
 116   1      //  7   |   6   |   5   |   4  |  3   |   2  |  1   | 0   |
C51 COMPILER V9.60.7.0   SERIALIO                                                          12/28/2023 16:26:10 PAGE 3   

 117   1      //---------------------------------------------------------
 118   1      // GATE1| C/T1  |    T1M[1:0]  | GATE0| C/T0 |  T0M[1:0]  |
 119   1      //---------------------------------------------------------
 120   1      #define B_T1M1 5
 121   1      #define B_T1M0 4
 122   1      
 123   1          //TMOD      = 0x20; // mode 2 8 bit auto-reload
 124   1          TMOD &= ~(1<<B_T1M0);
 125   1          TMOD |=  (1<<B_T1M1);
 126   1          
 127   1          TH1       = 0x30;
 128   1          TR1=1;
 129   1        
 130   1      //---------------------------------------------------------
 131   1      //   IE: Interrupt Enable
 132   1      //---------------------------------------------------------
 133   1      //  7   |   6   |   5   |   4  |  3   |   2  |  1   | 0   |
 134   1      //---------------------------------------------------------
 135   1      //  EA  | ESPI0 |  ET2  |  ES0 |  ET1 |  EX1 |  ET0 | EX0 |
 136   1      //--------------------------------------------------------- 
 137   1      #define B_EA 7
 138   1      #define B_ES0 4
 139   1          IE |= (1<<B_ES0);
 140   1      
 141   1      }
 142          
 143          /*------------------------------------------------------------------------------
 144          ------------------------------------------------------------------------------*/
 145          #pragma disable
 146          char uart0_putchar ( unsigned char c )
 147          {
 148   1        /*------------------------------------------------
 149   1        If the buffer is full, return an error value.
 150   1        ------------------------------------------------*/
 151   1        if (uart0_get_txbufsize () >= TBUF_SIZE)
 152   1          return (-ENOBUFS);
 153   1      
 154   1        /*------------------------------------------------
 155   1        Add the data to the transmit buffer.  If the
 156   1        transmit interrupt is disabled, then enable it.
 157   1        ------------------------------------------------*/
 158   1        TxBuff [TxWriteIndex & (TBUF_SIZE - 1)] = c;
 159   1        TxWriteIndex++;
 160   1      
 161   1        if (ti_restart)
 162   1        {
 163   2          ti_restart = 0;
 164   2          TI0 = 1;               /* generate transmit interrupt */
 165   2        }
 166   1      
 167   1        return (0);
 168   1      }
 169          
 170          /*------------------------------------------------------------------------------
 171          ------------------------------------------------------------------------------*/
 172          #pragma disable
 173          char uart0_getchar (void)
 174          {
 175   1        if (uart0_get_rxbufsize () == 0)
 176   1          return (-ENODATA);
 177   1      
 178   1        return (RxBuff [(RxReadIndex++) & (RBUF_SIZE - 1)]);
C51 COMPILER V9.60.7.0   SERIALIO                                                          12/28/2023 16:26:10 PAGE 4   

 179   1      }
 180          /*------------------------------------------------------------------------------
 181          ------------------------------------------------------------------------------*/
 182          #pragma disable
 183          unsigned char uart0_get_rxbufsize (void)
 184          {
 185   1        return (RxWriteIndex - RxReadIndex);
 186   1      }
 187          /*------------------------------------------------------------------------------
 188          ------------------------------------------------------------------------------*/
 189          #pragma disable
 190          unsigned char uart0_get_txbufsize (void)
 191          {
 192   1        return (TxWriteIndex - TxReadIndex);
 193   1      }
 194          
 195          /*------------------------------------------------------------------------------
 196          ------------------------------------------------------------------------------*/
 197          
 198          /*------------------------------------------------------------------------------
 199          _getkey waits until a character is received from the serial port. i.e. if the buffer is empty, this
 200          function hangs waiting for a character to be received.
 201          ------------------------------------------------------------------------------*/
 202          char _getkey (void)
 203          {
 204   1        int k;
 205   1      
 206   1        do
 207   1        {
 208   2          k = uart0_getchar ();
 209   2        }
 210   1        while (k == -ENODATA);
 211   1      
 212   1        return ((unsigned char) k);
 213   1      }
 214          /*------------------------------------------------------------------------------
 215          _getkey2 does not waits until a character is received from the serial port.  
 216          if the buffer is empty, this function will return -1.
 217          ------------------------------------------------------------------------------*/
 218          char _getkey2 (void)
 219          {
 220   1        return uart0_getchar ();
 221   1      }
 222          
 223          /*------------------------------------------------------------------------------
 224          ------------------------------------------------------------------------------*/
 225          char putchar (char c)
 226          {
 227   1        volatile unsigned int i;
 228   1        
 229   1        if(c == '\n') //on '\n', translate into '\r\n'
 230   1        {
 231   2          //try to enqueue the char, wait until it is accepted
 232   2          while (uart0_putchar ('\r') != 0)
 233   2            for (i=0; i<10; i++) //dummy sleep
 234   2              ;
 235   2        }
 236   1        //try to enqueue the char, wait until it is accepted
 237   1        while (uart0_putchar (c) != 0)
 238   1          for (i=0; i<10; i++)  //dummy sleep
 239   1            ;
 240   1      
C51 COMPILER V9.60.7.0   SERIALIO                                                          12/28/2023 16:26:10 PAGE 5   

 241   1        return (c);
 242   1      }
 243          
 244          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    382    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     32    ----
   DATA SIZE        =     10    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
