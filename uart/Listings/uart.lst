C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\uart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE uart.c LARGE OPTIMIZE(0,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\uart.lst) TABS(2) OBJECT(.\Objects\uart.obj)

line level    source

   1          #include <REG51F380.H>
   2          #include <stdio.h>
   3          #include <string.h>
   4          #include "types.h"
   5          
   6          #define B_TF3H 7
   7          #define B_TR3 2
   8          #define B_ET3 7
   9          
  10          sbit pb1 = P0^6;
  11          sbit pb2 = P0^7;
  12          
  13          /*********************************************************/
  14          typedef enum ENUM_STATES {S1 = 0, S2, S3, S4, S5} e_states;
  15          
  16          e_states state, nextstate;
  17          
  18          /*********************************************************
  19           * function prototypes                                   *
  20           *********************************************************/
  21          // init uart 0
  22          void uart0_init(void);
  23          // our simple printf version
  24          void print_u0(char* p_message);
  25          // our simple scanf version 
  26          char uart0_getc(char* c);
  27          // our putchar version 
  28          void uart0_putc(char c);
  29          //state machine
  30          void state_1(void);
  31          void state_2(void);
  32          void state_3(void);
  33          void state_4(void);
  34          void state_5(void);
  35          
  36          /*********************************************************/
  37              
  38          unsigned char vetor[16] = { 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 0xC6, 
             -0xA1, 0x86, 0x8E };
  39          
  40          //chave por defeito               8     0     5     1
  41          unsigned char default_key[4] = {0x80, 0xC0, 0x92, 0xF9};
  42           
  43          //                                  L     0     1     2     3     4     5     6     7     8     9
  44          unsigned char digits_array[11] = {0xC7, 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
  45          
  46          unsigned char button1pressed; //flags se os botoes sao clicados
  47          unsigned char button2pressed;
  48          unsigned int wrongkeycount;
  49          
  50          
  51          void timer3_init_auto(int reload){
  52   1      
  53   1        TMR3CN = 0;
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 2   

  54   1      
  55   1        #define B_T3MH 7  
  56   1      
  57   1        CKCON &= ~((1 << B_T3MH));
  58   1        
  59   1        TMR3H = (reload) >> 8;
  60   1        TMR3L = (reload);
  61   1      
  62   1        TMR3RLH = (reload) >> 8;
  63   1        TMR3RLL = (reload);
  64   1        
  65   1      }
  66          
  67          
  68          void timer2_init_auto(int reload){
  69   1      
  70   1        TMR2CN = 0;
  71   1      
  72   1        #define B_T2MH 5  
  73   1      
  74   1        CKCON &= ~((1 << B_T2MH));
  75   1        
  76   1        TMR2H = (reload) >> 8;
  77   1        TMR2L = (reload);
  78   1      
  79   1        TMR2RLH = (reload) >> 8;
  80   1        TMR2RLL = (reload);
  81   1        
  82   1      }
  83          
  84          void delay_250us(){
  85   1        while(!(TMR3CN & (1 << B_TF3H)));
  86   1        TMR3CN &= ~(1 << B_TF3H);  
  87   1      }
  88          
  89          void delay_s(unsigned int s) {
  90   1          unsigned int i = 0;
  91   1      
  92   1          while(i != (s*100)) {
  93   2              i++;
  94   2              while(!TF2H);
  95   2              TF2H = 0;
  96   2          }
  97   1      }
  98          
  99          
 100          void square_wave(){
 101   1        while (1){ // mudar para aceitar a HWFLAG
 102   2          //HIGH
 103   2          P1 |= 0x80;
 104   2          delay_250us();
 105   2          //LOW
 106   2          P1 &= ~(0x80);
 107   2          delay_250us();
 108   2        }
 109   1      }
 110          
 111          // validar a key introduzida pelo utilizador
 112          bit validate_key(unsigned char v1[4], unsigned char v2[4]){
 113   1        return memcmp(v1, v2, 4) == 0;
 114   1      }
 115          
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 3   

 116          //DEBOUNCE
 117          unsigned int debounce(bit PB){
 118   1              char window = 0;  
 119   1              unsigned int j;
 120   1          for(j = 0; j < 8; j++) {
 121   2              window = (window << 1) | PB;
 122   2          }
 123   1          return window;
 124   1      }
 125          
 126          // ler a key a ser posta pelo utilizador
 127          void read_key(){
 128   1          unsigned char button1pressed; //flags se os botoes sao clicados
 129   1          unsigned char button2pressed;
 130   1          unsigned int digit_index;     //index dos digitos
 131   1          unsigned int index_input_key; //index da key a ser lida
 132   1          unsigned char input_key[4];
 133   1          
 134   1      
 135   1        if(!debounce(pb2) && !button2pressed){
 136   2            button2pressed = 1; 
 137   2            input_key[index_input_key] = digits_array[digit_index];
 138   2            index_input_key++;
 139   2            digit_index = 0;
 140   2          }
 141   1          if(index_input_key == 4){
 142   2            if(validate_key(input_key,default_key)){
 143   3              index_input_key = 0;
 144   3              wrongkeycount = 0;
 145   3              nextstate = S2;
 146   3            }
 147   2            else{
 148   3              index_input_key = 0;
 149   3              nextstate = S3;
 150   3            }
 151   2          }
 152   1          if(debounce(pb2)){
 153   2            button2pressed = 0;
 154   2          }
 155   1        
 156   1          if(!debounce(pb1) && !button1pressed) {
 157   2            
 158   2            button1pressed = 1;            
 159   2            if (digit_index < 11) {
 160   3              digit_index++;
 161   3            }
 162   2            if (digit_index > 10){
 163   3              digit_index = 0;
 164   3            }
 165   2          }
 166   1          if(debounce(pb1)){
 167   2            button1pressed = 0;
 168   2          }
 169   1      
 170   1          P2 = digits_array[digit_index];
 171   1      }
 172          
 173          void errorhandling(){
 174   1          wrongkeycount++;
 175   1          if(wrongkeycount == 1){
 176   2            P2 = 0x86; // E
 177   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 4
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 4   

             - segundos num total de 5 segundos
 178   2            P2 = 0xC6; // C
 179   2            delay_s(4);//wait 4 secs
 180   2            nextstate = S1;
 181   2          }
 182   1          if(wrongkeycount == 2){
 183   2            P2 = 0x86; // E
 184   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 9
             - segundos
 185   2            P2 = 0xC6; // C
 186   2            delay_s(9);//wait 9 secs
 187   2            nextstate = S1;
 188   2          }
 189   1          if(wrongkeycount == 3){
 190   2            P2 = 0x86; // E
 191   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 1
             -4 segundos
 192   2            P2 = 0xC6; // C
 193   2            delay_s(14);//wait 14 secs
 194   2            nextstate = S1;
 195   2          }
 196   1          if(wrongkeycount == 4){
 197   2            P2 = 0x86; // E
 198   2            delay_s(1); //diz que foi erro pelo E no display passado 1 segundo muda para C de close e espera mais 1
             -9 segundos
 199   2            P2 = 0xC6; // C
 200   2            delay_s(19);//wait 19 secs
 201   2            nextstate = S1;
 202   2          }
 203   1          if(wrongkeycount == 5){
 204   2            nextstate = S4;
 205   2          }
 206   1      }
 207          
 208          void open_menu(){//                 O       P     C
 209   1          unsigned int open_menu[3] = {0xA3 , 0x8C, 0xC6};
 210   1          unsigned int index;
 211   1          
 212   1          if(!debounce(pb2) && !button2pressed){
 213   2            button2pressed = 1;
 214   2            if(open_menu[index] == 0x8C){
 215   3              nextstate = S5;
 216   3              index = 0;
 217   3            }
 218   2            if(open_menu[index] == 0xC6){
 219   3              nextstate = S1;
 220   3              index = 0;
 221   3            }
 222   2          }
 223   1          
 224   1          if(debounce(pb2)){
 225   2            button2pressed = 0;
 226   2          }
 227   1          
 228   1          if(!debounce(pb1) && !button1pressed){
 229   2            
 230   2            
 231   2            button1pressed = 1;            
 232   2            if (index < 3){
 233   3              index++;
 234   3            }
 235   2            if (index > 2){
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 5   

 236   3              index = 0;
 237   3            }
 238   2          }
 239   1          
 240   1          if(debounce(pb1)){
 241   2            button1pressed = 0;
 242   2          }
 243   1      
 244   1          P2 = open_menu[index];
 245   1        
 246   1      }
 247          void set_key(){//                 P     0     1     2     3     4     5     6     7     8     9
 248   1          unsigned int set_key[11] = {0x8C, 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};
 249   1          unsigned int index;
 250   1          unsigned int index_new_key;
 251   1          
 252   1          if(!debounce(pb2) && !button2pressed){
 253   2            button2pressed = 1;
 254   2            default_key[index_new_key] = set_key[index];
 255   2            index_new_key++;
 256   2            index = 0;
 257   2          }
 258   1          
 259   1          if(index_new_key == 4){
 260   2            index_new_key = 0;
 261   2            nextstate = S1;
 262   2          }
 263   1          
 264   1          if(debounce(pb2)){
 265   2            button2pressed = 0;
 266   2          }
 267   1          
 268   1          if(!debounce(pb1) && !button1pressed){
 269   2            
 270   2            button1pressed = 1;            
 271   2            if (index < 11){
 272   3              index++;
 273   3            }
 274   2            if (index > 10){
 275   3              index = 0;
 276   3            }
 277   2          }
 278   1          
 279   1          if(debounce(pb1)){
 280   2            button1pressed = 0;
 281   2          }
 282   1      
 283   1          P2 = set_key[index];
 284   1      }
 285          
 286          
 287          /*********************************************************/ 
 288          //                          close/locked    open    error     alarm   set_key
 289          void (*state_process [])(void) = {state_1, state_2, state_3, state_4, state_5};
 290          
 291          
 292          void state_1(void){
 293   1          read_key();
 294   1          P1 = 0x10;
 295   1      }
 296          void state_2(void){
 297   1          open_menu();
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 6   

 298   1          P1 &= ~(0x10);
 299   1      }
 300          void state_3(void){
 301   1          errorhandling();
 302   1      }
 303          void state_4(void){
 304   1          P2 = 0x88;
 305   1          square_wave();
 306   1      }
 307          void state_5(void){
 308   1          set_key();
 309   1      }
 310          
 311          /*********************************************************/
 312          void encode_FSM(){
 313   1          state_process[state] ();
 314   1      }
 315          
 316          /*********************************************************/
 317          
 318          /*********************************************************
 319           * uart0 init                                            *
 320           *********************************************************/
 321          void uart0_init(void){  
 322   1          /* UART0 Control                            */
 323   1          /* set REN0, enable reception               */
 324   1          SCON0     = 0x10;
 325   1        
 326   1          /* Timer/Counter Mode                       */  
 327   1          TMOD      = 0x20;
 328   1        
 329   1          /* Clock Control                            */
 330   1          CKCON     = 0x08;
 331   1        
 332   1          /* Timer/Counter 1 High                     
 333   1           * 0x30 generates a baudrate of 115200 bps  */
 334   1          TH1       = 0x30;
 335   1        
 336   1          /* Timer 1 On/Off Control                   */
 337   1          TR1       = 1;
 338   1        
 339   1          /* UART0 TX Interrupt Flag                  */
 340   1          TI0       = 1;
 341   1          RI0 = 1;
 342   1      }
 343          /*********************************************************
 344           * print using uart0                                     *
 345           *********************************************************/
 346          void print_u0(char* p_message){
 347   1        
 348   1        unsigned char i = 0;
 349   1        
 350   1        while(p_message[i] != 0){
 351   2          
 352   2          /* Transmission flag                            */
 353   2          while(TI0 == 0);
 354   2          
 355   2          /* UART write/read buffer (1 byte only)         */
 356   2          SBUF0 = p_message[i];
 357   2          
 358   2          /* Transmission flag control. set by hardware.  */
 359   2          TI0 = 0;
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 7   

 360   2          i++;
 361   2        }
 362   1      }
 363          
 364          /*********************************************************
 365           * putc using uart0                                      *
 366           *********************************************************/
 367          void uart0_putc(char c){
 368   1        
 369   1        while(TI0 == 0);
 370   1        TI0 = 0;
 371   1        SBUF0 = c;
 372   1        
 373   1      }
 374          
 375          /*********************************************************
 376           * getc using uart0                                      *
 377           *********************************************************/
 378          char uart0_getc(char* c){
 379   1      
 380   1        if(RI0 == 1){
 381   2          RI0 = 0;
 382   2          *c = SBUF0; 
 383   2          return 1;
 384   2        }
 385   1        return 0;
 386   1      }
 387           
 388          
 389          
 390          /*********************************************************/ 
 391          void Init_Device(void){
 392   1        
 393   1        /* Disable WDT */
 394   1        PCA0MD    = 0x00;
 395   1        /* select clock source */
 396   1        FLSCL     = 0x90;
 397   1        CLKSEL    = 0x03;
 398   1        /* enable cross-bar for I/Os */
 399   1        XBR1      = 0x40;
 400   1        /* enable uart0 with TX pin on P0.4 and RX pin on P0.5 */
 401   1        XBR0      = 0x01;
 402   1      }
 403          
 404          /*********************************************************
 405           * my main loop                                          *
 406           *********************************************************/
 407          void main (void){
 408   1        
 409   1        // to store the received or transmitted byte
 410   1        char c = 0;
 411   1        unsigned int i = 0;
 412   1        
 413   1        
 414   1        Init_Device();  
 415   1        uart0_init();
 416   1        
 417   1        timer2_init_auto(-40000);
 418   1        timer3_init_auto(-1000);
 419   1        
 420   1        state = nextstate = S1;
 421   1        
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 8   

 422   1        //Set by hardware when the Timer 2/3 high byte overflows from 0xFF to 0x00. In 16 bit 
 423   1        //mode, this will occur when Timer 2/3 overflows from 0xFFFF to 0x0000.   
 424   1        TF2H = 0; 
 425   1        TMR3CN &= ~(1 << B_TF3H);
 426   1        
 427   1        // Enable Flag Timer 2/3 Overflow
 428   1        ET2 = 1;
 429   1        EIE1 |= (1 << B_ET3);
 430   1        
 431   1        // Timer 2/3 Run Control. Timer 2/3 is enabled by setting this bit to 1. 
 432   1        TMR3CN |= (1 << B_TR3);
 433   1        TR2 = 1;
 434   1        
 435   1        /* Global Interrupt Enable */
 436   1        EA = 1; 
 437   1        
 438   1        /* print message using printf from stdlib.h */
 439   1        printf("Pronto a usar");
 440   1        
 441   1        
 442   1      //  /* print a char from our putchar */
 443   1      //  uart0_putc('L');
 444   1      //  uart0_putc('E');
 445   1      //  uart0_putc('T');
 446   1      //  uart0_putc('I');
 447   1      //  uart0_putc('\n');
 448   1      
 449   1      //  /* print a message using our print function */
 450   1      //  print_u0(message_u0);
 451   1            
 452   1        while(1){
 453   2        
 454   2      //  if(uart0_getc(&c)){
 455   2      //      if(c == 0x2b){ // caracter +
 456   2      //        printf("valor :");
 457   2      //          if (i < 15) {
 458   2      //                i++;
 459   2      //            } else {
 460   2      //                i = 15;
 461   2      //            }
 462   2      //            printf("%d\n",i);
 463   2      //      }
 464   2      //    }
 465   2      //    if(uart0_getc(&c)){
 466   2      //      if(c == 0x2d){ // caracter -
 467   2      //        printf("valor :");
 468   2      //           if (i > 0) {
 469   2      //                i--;
 470   2      //            } else {
 471   2      //                i = 0;
 472   2      //            }
 473   2      //            printf("%d\n",i);
 474   2      //      }
 475   2      //    }
 476   2      //    P2 = vetor[i];
 477   2          
 478   2          /*********************************************************
 479   2          * stm                                        *
 480   2          *********************************************************/
 481   2          encode_FSM();
 482   2          state = nextstate;
 483   2        }
C51 COMPILER V9.60.7.0   UART                                                              11/09/2023 16:37:29 PAGE 9   

 484   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1696    ----
   CONSTANT SIZE    =     42    ----
   XDATA SIZE       =    124    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
